/**
 * GitHub Issue Reporter for Test Automation
 * Automatically creates GitHub issues for test failures
 */

export interface TestFailure {
  testName: string;
  testFile: string;
  errorMessage: string;
  stackTrace?: string;
  screenshot?: string;
  videoPath?: string;
  tracePath?: string;
  browser?: string;
  viewport?: string;
  timestamp: Date;
  severity: 'critical' | 'high' | 'medium' | 'low';
  category: 'validation' | 'responsive' | 'theme' | 'integration' | 'e2e';
}

export interface GitHubIssueResult {
  success: boolean;
  issueNumber?: number;
  issueUrl?: string;
  error?: string;
}

/**
 * Create a GitHub issue for a test failure
 */
export async function createGitHubIssue(
  failure: TestFailure
): Promise<GitHubIssueResult> {
  try {
    const githubToken = process.env.GITHUB_TOKEN;
    const githubRepo = 'rshetty-99/atraiva-mvp'; // Your repository

    if (!githubToken) {
      console.warn('GITHUB_TOKEN not found. Issue not created.');
      return {
        success: false,
        error: 'GITHUB_TOKEN not found in environment variables',
      };
    }

    const title = `[Test Failure] ${failure.testName}`;
    const body = generateIssueBody(failure);
    const labels = generateLabels(failure);

    const response = await fetch(
      `https://api.github.com/repos/${githubRepo}/issues`,
      {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${githubToken}`,
          'Content-Type': 'application/json',
          'Accept': 'application/vnd.github.v3+json',
        },
        body: JSON.stringify({
          title,
          body,
          labels,
        }),
      }
    );

    if (!response.ok) {
      const errorData = await response.json();
      return {
        success: false,
        error: JSON.stringify(errorData),
      };
    }

    const data = await response.json();
    return {
      success: true,
      issueNumber: data.number,
      issueUrl: data.html_url,
    };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
    };
  }
}

/**
 * Generate issue body with detailed information
 */
function generateIssueBody(failure: TestFailure): string {
  const sections = [];

  // Header
  sections.push('## Test Failure Report');
  sections.push('');
  sections.push(`**Test Name:** ${failure.testName}`);
  sections.push(`**Test File:** ${failure.testFile}`);
  sections.push(`**Timestamp:** ${failure.timestamp.toISOString()}`);
  sections.push(`**Severity:** ${failure.severity.toUpperCase()}`);
  sections.push(`**Category:** ${failure.category}`);
  sections.push('');

  // Environment
  sections.push('## Environment');
  if (failure.browser) {
    sections.push(`**Browser:** ${failure.browser}`);
  }
  if (failure.viewport) {
    sections.push(`**Viewport:** ${failure.viewport}`);
  }
  sections.push('');

  // Error Details
  sections.push('## Error Details');
  sections.push('```');
  sections.push(failure.errorMessage);
  sections.push('```');
  sections.push('');

  // Stack Trace
  if (failure.stackTrace) {
    sections.push('## Stack Trace');
    sections.push('```');
    sections.push(failure.stackTrace);
    sections.push('```');
    sections.push('');
  }

  // Artifacts
  sections.push('## Test Artifacts');
  if (failure.screenshot) {
    sections.push(`- ðŸ“¸ Screenshot: \`${failure.screenshot}\``);
  }
  if (failure.videoPath) {
    sections.push(`- ðŸŽ¥ Video: \`${failure.videoPath}\``);
  }
  if (failure.tracePath) {
    sections.push(`- ðŸ“Š Trace: \`${failure.tracePath}\``);
  }
  sections.push('');

  // Reproduction Steps
  sections.push('## Reproduction Steps');
  sections.push('1. Run the test: `npx playwright test ' + failure.testFile + '`');
  sections.push('2. Open the trace viewer: `npx playwright show-trace ' + (failure.tracePath || 'trace.zip') + '`');
  sections.push('');

  // Additional Context
  sections.push('## Additional Context');
  sections.push('This issue was automatically generated by the onboarding test suite.');
  sections.push('');

  // Checklist
  sections.push('## Resolution Checklist');
  sections.push('- [ ] Reproduce the issue locally');
  sections.push('- [ ] Identify root cause');
  sections.push('- [ ] Implement fix');
  sections.push('- [ ] Add regression test');
  sections.push('- [ ] Verify fix in all supported browsers');
  sections.push('- [ ] Update documentation if needed');

  return sections.join('\n');
}

/**
 * Generate appropriate labels for the issue
 */
function generateLabels(failure: TestFailure): string[] {
  const labels = ['bug', 'automated-test', 'onboarding'];

  // Severity label
  labels.push(`severity:${failure.severity}`);

  // Category label
  switch (failure.category) {
    case 'validation':
      labels.push('validation', 'forms');
      break;
    case 'responsive':
      labels.push('responsive', 'ui');
      break;
    case 'theme':
      labels.push('theme', 'dark-mode', 'ui');
      break;
    case 'integration':
      labels.push('integration', 'backend');
      break;
    case 'e2e':
      labels.push('e2e', 'end-to-end');
      break;
  }

  return labels;
}

/**
 * Create multiple GitHub issues for multiple failures
 */
export async function createGitHubIssuesForFailures(
  failures: TestFailure[]
): Promise<GitHubIssueResult[]> {
  const results: GitHubIssueResult[] = [];

  for (const failure of failures) {
    const result = await createGitHubIssue(failure);
    results.push(result);
    
    // Add delay to avoid rate limiting
    if (failures.length > 1) {
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
  }

  return results;
}

/**
 * Check if an issue already exists for a test failure
 */
export async function checkExistingIssue(testName: string): Promise<boolean> {
  try {
    const githubToken = process.env.GITHUB_TOKEN;
    const githubRepo = 'rshetty-99/atraiva-mvp';

    if (!githubToken) {
      return false;
    }

    const searchQuery = encodeURIComponent(
      `repo:${githubRepo} is:issue is:open "${testName}" in:title`
    );

    const response = await fetch(
      `https://api.github.com/search/issues?q=${searchQuery}`,
      {
        headers: {
          'Authorization': `Bearer ${githubToken}`,
          'Accept': 'application/vnd.github.v3+json',
        },
      }
    );

    if (!response.ok) {
      return false;
    }

    const data = await response.json();
    return data.total_count > 0;
  } catch (error) {
    console.error('Error checking existing issue:', error);
    return false;
  }
}

/**
 * Create issue only if it doesn't already exist
 */
export async function createGitHubIssueIfNotExists(
  failure: TestFailure
): Promise<GitHubIssueResult> {
  const exists = await checkExistingIssue(failure.testName);
  
  if (exists) {
    return {
      success: true,
      error: 'Issue already exists',
    };
  }

  return createGitHubIssue(failure);
}

